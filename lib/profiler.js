import testing from 'testing'

// globals
var profilers = {};
var enabled = true;


/**
 * Convenience function, just returns process.hrtime().
 */
export function start() {
	return process.hrtime();
}

/**
 * Measure from the given time, with the desired key. Returns the time in µs. Params:
 *	- before: time generated by process.hrtime() from which to start measuring.
 *	- key: optional identifier for the profiling.
 *	- showEvery: optional parameter to show results every given iterations.
 */
export function measureFrom(before, key, showEvery) {
	if (!enabled) {
		return;
	}
	var elapsed = process.hrtime(before);
	var diffUs = elapsed[0] * 1e6 + elapsed[1] / 1000;
	if (key) {
		getProfiler(key, showEvery).measure(diffUs);
	}
	return diffUs;
}

function getProfiler(key, showEvery)
{
	if (!profilers[key] || typeof profilers[key] == 'function')
	{
		profilers[key] = new Profiler(key, showEvery);
	}
	return profilers[key];
}

/**
 * Test how long profiling takes.
 */
function testProfilingProfiler(callback)
{
	var runs = 10000;
	for (var i = 0; i < runs; i++)
	{
		var now = start();
		measureFrom(now, 'fake');
		measureFrom(now, 'profile');
	}
	var stats = getStats('profile');
	testing.assert(stats.meanTimeUs < 5, 'Profiling should take less than 5 µs, took: ' + stats.meanTimeUs, callback);
	testing.success(callback);
}

/**
 * Show profiling data for a key.
 */
export function show(key, showEvery) {
	if (!enabled) {
		return;
	}
	getProfiler(key, showEvery).show();
}

/**
 * Get an object with stats.
 */
export function getStats(key, showEvery) {
	return getProfiler(key, showEvery).getStats(key);
}

/**
 * Disable the whole module.
 */
export function disable() {
	enabled = false;
}

/**
 * Measure some times, show every few requests.
 */
function Profiler(name, showEvery)
{
	this.name = name;
	this.showEvery = showEvery;
	this.requests = 0;
	this.timeUs = 0;
}

/**
 * Take a measurement, show results every few requests.
 */
Profiler.prototype.measure = function(elapsedUs)
{
	this.requests += 1;
	this.timeUs += elapsedUs;
	if (this.showEvery && this.requests % this.showEvery === 0)
	{
		this.show();
	}
};

Profiler.prototype.show = function()
{
	var stats = this.getStats();
	console.info('Profiling %s: %s requests, mean time: %s µs, rps: %s', this.name, this.requests, stats.meanTimeUs, stats.rps);
	this.requests = 0;
	this.timeUs = 0;
};

Profiler.prototype.getStats = function()
{
	return {
		key: this.name,
		requests: this.requests,
		timeUs: this.timeUs,
		meanTimeUs: (this.timeUs / this.requests).toFixed(3),
		rps: Math.round(this.requests / (this.timeUs / 1e6)),
	};
};

Profiler.prototype.toString = function()
{
	return 'profiler for ' + this.name;
};

/**
 * Test the profiler.
 */
function testProfiler(callback)
{
	var runs = 100000;
	var now = start();
	var profiler = new Profiler('first');
	var before;
	for (var i = 0; i < runs; i++)
	{
		before = start();
		const elapsedUs = measureFrom(before);
		testing.assert(elapsedUs, 'measureFrom() should return something', callback);
		profiler.measure(elapsedUs);
	}
	var stats = profiler.getStats();
	testing.assert(stats, 'No profiler stats', callback);
	testing.assert(stats.timeUs, 'Profiler stats should not be zero', callback);
	for (i = 0; i < runs; i++)
	{
		before = start();
		const elapsedUs = measureFrom(before, 'second', runs);
		testing.assert(elapsedUs, 'measureFrom() should not decrease', callback);
	}
	var fromStart = measureFrom(now, 'fromStart');
	testing.assert(fromStart, 'measureFrom() start should not be zero', callback);
	testing.success(callback);
}

export function test(callback) {
	testing.run([
		testProfilingProfiler,
		testProfiler,
	], callback);
}

