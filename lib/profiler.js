'use strict';

/**
 * Microprofiler.
 * (C) 2014 Alex Fernández.
 */


// requires
var Log = require('log');
var testing = require('testing');

// globals
var log = new Log('info');
var profilers = {};
var enabled = true;


/**
 * Convenience function, just returns process.hrtime().
 */
exports.start = function()
{
	return process.hrtime();
};

/**
 * Measure from the given time, with the desired key. Returns the time in µs. Params:
 *	- before: time generated by process.hrtime() from which to start measuring.
 *	- key: identifier for the profiling.
 *	- showEvery: optional parameter to show results every given iterations.
 */
exports.measureFrom = function(before, key, showEvery)
{
	if (!enabled)
	{
		return;
	}
	if (!key)
	{
		return log.error('Missing profiler key; please specify as a second parameter');
	}
	return getProfiler(key, showEvery).measure(before);
};

function getProfiler(key, showEvery)
{
	if (!profilers[key] || typeof profilers[key] == 'function')
	{
		profilers[key] = new Profiler(key, showEvery);
	}
	return profilers[key];
}

/**
 * Test how long profiling takes.
 */
function testProfilingProfiler(callback)
{
	var runs = 10000;
	for (var i = 0; i < runs; i++)
	{
		var start = exports.start();
		exports.measureFrom(start, 'fake');
		exports.measureFrom(start, 'profile');
	}
	var stats = exports.getStats('profile');
	testing.assert(stats.meanTimeUs < 3, 'Profiling should take less than 3 µs, took: ' + stats.meanTimeUs, callback);
	testing.success(callback);
}

/**
 * Show profiling data for a key.
 */
exports.show = function(key, showEvery)
{
	if (!enabled)
	{
		return;
	}
	getProfiler(key, showEvery).show();
};

/**
 * Get an object with stats.
 */
exports.getStats = function(key, showEvery)
{
	return getProfiler(key, showEvery).getStats(key);
};

/**
 * Disable the whole module.
 */
exports.disable = function()
{
	enabled = false;
};

/**
 * Measure some times, show every few requests.
 */
function Profiler(name, showEvery)
{
	// self-reference
	var self = this;

	// attributes
	var requests = 0;
	var timeUs = 0;

	/**
	 * Take a measurement, show results every few requests.
	 */
	self.measure = function(before)
	{
		requests += 1;
		var elapsed = process.hrtime(before);
		var diffUs = elapsed[0] * 1e6 + elapsed[1] / 1000;
		timeUs += diffUs;
		if (showEvery && requests % showEvery === 0)
		{
			self.show();
		}
		return diffUs;
	};

	self.show = function()
	{
		var stats = self.getStats();
		log.info('Profiling %s: %s requests, mean time: %s µs, rps: %s', name, requests, stats.meanTimeUs, stats.rps);
		requests = 0;
		timeUs = 0;
	};

	self.getStats = function()
	{
		return {
			key: name,
			requests: requests,
			timeUs: timeUs,
			meanTimeUs: (timeUs / requests).toFixed(2),
			rps: Math.round(requests / (timeUs / 1e6)),
		};
	};
}

/**
 * Test the profiler.
 */
function testProfiler(callback)
{
	var runs = 100000;
	var start = exports.start();
	var profiler = new Profiler('first', runs);
	var before;
	for (var i = 0; i < runs; i++)
	{
		before = exports.start();
		var measure = profiler.measure(before);
		testing.assert(measure, 'measure() should not be zero', callback);
	}
	var fromStart = profiler.measure(start);
	testing.assert(fromStart, 'measure() from start should not be zero', callback);
	for (i = 0; i < runs; i++)
	{
		before = exports.start();
		var measureFrom = exports.measureFrom(before, 'second', runs);
		testing.assert(measureFrom, 'measureFrom() should not decrease', callback);
	}
	fromStart = exports.measureFrom(start, 'fromStart');
	testing.assert(fromStart, 'measureFrom() start should not be zero', callback);
	testing.success(callback);
}

/**
 * Run all tests.
 */
exports.test = function(callback)
{
	log.debug('Running tests');
	testing.run([
		testProfilingProfiler,
		testProfiler,
	], callback);
};

// run tests if invoked directly
if (__filename == process.argv[1])
{
	exports.test(testing.show);
}

